import os
import ipaddress

from snort_rulegen.rule_templates import build_rule
from snort_rulegen.sid_manager import get_next_sid


def prompt_protocol():
    while True:
        proto = input("Protocol [tcp/udp/icmp]: ").strip().lower()
        if proto in ("tcp", "udp", "icmp", ""):
            return proto or "tcp"
        print("Invalid protocol. Choose from tcp, udp, icmp.")


def prompt_ip(prompt_text, allow_vars=False, default=None):
    while True:
        val = input(prompt_text).strip()
        if not val and default:
            return default
        if val.lower() == "any":
            return "any"
        if allow_vars and val.startswith("$"):
            return val
        try:
            ipaddress.ip_address(val)
            return val
        except ValueError:
            print("Invalid IP address.")


def prompt_port(prompt_text):
    while True:
        val = input(prompt_text).strip()
        if val.lower() == "any" or val == "":
            return "any"
        try:
            port = int(val)
            if 0 <= port <= 65535:
                return str(port)
            print("Port must be between 0 and 65535.")
        except ValueError:
            print("Invalid port. Must be an integer or 'any'.")


def run():
    print("Snort Rule Generator")
    print("--------------------")

    proto = prompt_protocol()
    src_ip = prompt_ip("Source IP [any]: ", allow_vars=False) or "any"
    src_port = prompt_port("Source Port [any]: ")
    dst_ip = prompt_ip("Destination IP [$HOME_NET]: ", allow_vars=True, default="$HOME_NET") or "$HOME_NET"
    dst_port = prompt_port("Destination port [80]: ") or "80"

    content = input("Content to match (e.g., cmd.exe): ").strip()
    nocase = input("Apply nocase (case-insensitive match)? [y/N]: ").strip().lower() == "y"

    msg = input("Rule message: ").strip() or "Generated by SnortGen"

    sid = get_next_sid()
    rule = build_rule(proto, src_ip, src_port, dst_ip, dst_port, msg, content, sid, nocase=nocase)

    print("\nGenerated Rule:")
    print(rule)

    out_path = "rules/local.rules"
    os.makedirs(os.path.dirname(out_path), exist_ok=True)

    with open(out_path, "a") as f:
        f.write(rule + "\n")

    print(f"\nRule saved to {out_path}")