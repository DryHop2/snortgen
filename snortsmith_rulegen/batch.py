import os
import json
from snortsmith_rulegen.rule_templates import build_rule
from snortsmith_rulegen.sid_manager import get_next_sid
from snortsmith_rulegen.utils import (
    validate_protocol,
    validate_ip,
    validate_port,
    validate_priority,
    validate_pcre,
    validate_flags,
    validate_metadata,
    validate_msg,
    validate_offset_depth,
    validate_reference,
    get_latest_revision,
    resolve
)

def run_batch(filepath, outfile="rules/local.rules", verbose=False, dry_run=False, config=None):
    """
    Processes a JSON file of rule definitions and writes valid Snort rules to the specified output file(s).

    Args:
        filepath (str): Path to the JSON file containing a list of rule dicts.
        outfile (str): Default output file path if not overridden per rule.
        verbose (bool): If True, prints generated rules and status messages.
        dry_run (bool): If True, rules are previewed but not saved unless user confirms.
        config (dict): Optional config overrides (usually from snortsmith.conf).
    """

    try:
        with open(filepath, "r") as f:
            data = json.load(f)

        if not isinstance(data, list):
            print("[ERROR] Batch file must contain a list of rule objects.")
            return
        
        generated = 0
        skipped = 0
        rules_to_write = []

        config = config or {}

        for idx, rule in enumerate(data, 1):
            try:
                # Resolve values from rule -> config -> fallback
                out_path = resolve(rule.get("outfile"), config, "default_outfile", "rules/local.rules")
                proto = validate_protocol(resolve(rule.get("proto"), config, "default_proto", "tcp"))
                src_ip = validate_ip(resolve(rule.get("src_ip"), config, "default_src_ip", "any"))
                src_port = validate_port(resolve(rule.get("src_prt"), config, "default_src_port", "any"))
                dst_ip = validate_ip(resolve(rule.get("dst_ip"), config, "default_dst_ip", "$HOME_NET"))
                dst_port = validate_port(resolve(rule.get("dst_port"), config, "default_dst_port", "80"))
                msg = validate_msg(resolve(rule.get("msg"), config, "default_msg", "Generated by Snortsmith"))
                content = resolve(rule.get("content"), config, "default_content", None)
                nocase = resolve(rule.get("nocase"), config, "default_nocase", False)
                offset = resolve(rule.get("offset"), config, "default_offset", None)
                depth = resolve(rule.get("depth"), config, "default_depth", None)
                if offset is not None or depth is not None:
                    offset, depth = validate_offset_depth(offset, depth)
                flags = validate_flags(resolve(rule.get("flags"), config, "default_flags", None)) if rule.get("flags") or config.get("default_flags") else None
                pcre = validate_pcre(resolve(rule.get("pcre"), config, "default_pcre", None)) if rule.get("pcre") or config.get("default_pcre") else None
                classtype = resolve(rule.get("classtype"), config, "default_classtype", None)
                priority = validate_priority(resolve(rule.get("priority"), config, "default_priority", None)) if rule.get("priority") or config.get("default_priority") else None
                metadata = validate_metadata(resolve(rule.get("metadata"), config, "default_metadata", None)) if rule.get("metadata") or config.get("default_metadata") else None
                reference = validate_reference(resolve(rule.get("reference"), config, "default_reference", None)) if rule.get("reference") or config.get("default_reference") else None

                # SID + revision tracking
                sid = resolve(rule.get("sid"), config, "sid", None)
                if sid is None:
                    sid = get_next_sid()
                rev = get_latest_revision(out_path, sid)

                # Build rule string
                snort_rule = build_rule(
                    proto=proto, 
                    src_ip=src_ip, 
                    src_port=src_port, 
                    dst_ip=dst_ip, 
                    dst_port=dst_port,
                    msg=msg, 
                    content=content, sid=
                    sid, 
                    rev=rev,
                    nocase=nocase,
                    offset=offset,
                    depth=depth,
                    flags=flags,
                    pcre=pcre,
                    classtype=classtype,
                    priority=priority,
                    metadata=metadata,
                    reference=reference
                )

                # Optional comment
                comment = rule.get("comment", "").strip()
                if comment:
                    snort_rule += f"  # {comment}"
                
                # Preview rule if requested
                if dry_run or verbose:
                    print(f"[Rule {idx}] {snort_rule}")

                rules_to_write.append((snort_rule, out_path))
                generated += 1

            except Exception as e:
                print(f"[Rule {idx}] Skipped: {e}")
                skipped += 1
        
        print(f"\nBatch complete: {generated} rule(s) written, {skipped} skipped.")

        # Dry run confirmation prompt
        if dry_run:
            confirm = input("\nSave all displayed rules to file? [y/N]: ").strip().lower()
            if confirm != "y":
                print("Batch aborted, no rules written.")
                return
        
        # Group rules output path
        file_groups = {}
        for rule, path in rules_to_write:
            file_groups.setdefault(path, []).append(rule)

        # Write rules to their respective output files
        for path, rules in file_groups.items():
            print(f"\nWriting {len(rules)} rule(s) to {path}...")
            dir_path = os.path.dirname(outfile) or "."
            os.makedirs(dir_path, exist_ok=True)
            with open(path, "a") as out:
                for rule in rules:
                    out.write(rule + "\n")

    except FileNotFoundError:
        print(f"[ERROR] Batch file not found: {filepath}")
    except json.JSONDecodeError as e:
        print(f"[ERROR] Invalid JSON in batch file: {e}")
    except Exception as e:
        print(f"[ERROR] Unexpected error during batch processing: {e}")