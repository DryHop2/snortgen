import os

from snortsmith_rulegen._rule_templates import _build_rule
from snortsmith_rulegen._sid_manager import _get_next_sid
from snortsmith_rulegen._utils import (
    _validate_protocol,
    _validate_ip,
    _validate_port,
    _validate_priority,
    _validate_offset_depth,
    _validate_flags,
    _validate_pcre,
    _validate_metadata,
    _validate_msg,
    _validate_reference,
    _get_latest_revision,
    _resolve
)


def run_interactive() -> None:
    """
    Launches the interactive Snort rule creation prompt.
    Guides the user through each field and saves the generated rule.
    """
    print("Snort Rule Generator")
    print("--------------------")

    # Required: Protocol
    proto = input("Protocol [tcp/udp/icmp/ip] (default: tcp) ").strip().lower() or "tcp"
    try:
        proto = _validate_protocol(proto)
    except ValueError as e:
        print(f"Protocol error: {e}")
        return
    
    # Required: IPs and Ports
    src_ip = input("Source IP [any]: ").strip() or "any"
    src_port = input("Source Port [any]: ").strip() or "any"
    dst_ip = input("Destination IP [$HOME_NET]: ").strip() or "$HOME_NET"
    dst_port = input("Destination port [80]: ").strip() or "80"

    try:
        src_ip = _validate_ip(src_ip)
        dst_ip = _validate_ip(dst_ip)
        src_port = _validate_port(src_port)
        dst_port = _validate_port(dst_port)
    except ValueError as e:
        print(f"Input error: {e}")
        return
    
    # Optional: Content match
    content = input("Content to match (e.g., cmd.exe): ").strip()
    nocase = input("Apply nocase (case-insensitive match)? [y/N]: ").strip().lower() == "y"
    
    offset = input("Set offset (starting byte for search, leave blank to skip): ").strip()
    depth = input("Set depth (max bytes to search, leave blank to skip): ").strip()
    try:
        offset, depth = _validate_offset_depth(offset, depth)
    except ValueError as e:
        print(f"Offset/depth error: {e}")
        offset = None
        depth = None
    
    # Optional: TCP flags
    flags = input("TCP flags to match (e.g., S, SA, leave blank to skip): ").strip().upper()
    if flags:
        try:
            flags = _validate_flags(flags)
        except ValueError as e:
            print(f"Flags error: {e}")
            flags = None

    # Optional: PCRE
    pcre = input("Add PCRE regex match (format: /regex/modifiers, leave blank to skip): ").strip()
    if pcre:
        try:
            pcre = _validate_pcre(pcre)
        except ValueError as e:
            print(f"PCRE error: {e}")
            pcre = None
    
    # Optional: Classtype and priority
    classtype = input("Set classtype (e.g., attempted-admin, leave blank to skip): ").strip().lower()
    priority = input("Set priority (1 = high, 3 = low, leave blank to skip): ").strip()
    if priority:
        try:
            priority = _validate_priority(priority)
        except ValueError as e:
            print(f"Priority error: {e}")
            priority = None
    
    # Optional: Metadata
    metadata = None
    use_metadata = input("Would you like to add metadata to Snort rule? [y/N]: ").strip().lower() == "y"
    if use_metadata:
        raw = input("Enter metadata (e.g., key value, key value): ").strip()
        try:
            metadata = _validate_metadata(raw)
        except ValueError as e:
            print(f"Metadata error: {e}")

    # Optional: Reference
    reference = input("Add reference (format: type, value - e.g., cve,2021-44228 or url, https://....) [leave blank to skip]: ").strip()
    if reference:
        try:
            reference = _validate_reference(reference)
        except ValueError as e:
            print(f"Reference error: {e}")
            reference = None

    # Required: Message
    msg = input("Rule message: (default: Generated by Snortsmith): ").strip() or "Generated by Snortsmith"
    msg = _validate_msg(msg)

    # Output path
    default_out = "rules/local.rules"
    out_path = input(f"\nOutput path (default: {default_out}): ").strip() or default_out

    # SID & Revision
    sid_input = input("SID (leave blank to auto-generate): ").strip()
    try:
        sid = int(sid_input) if sid_input else _get_next_sid()
    except ValueError:
        print("Invalid SID. Auto-generating instead.")
        sid = _get_next_sid()

    rev = _get_latest_revision(out_path, sid)

    # Rule construction
    rule = _build_rule(proto=proto, 
                      src_ip=src_ip, 
                      src_port=src_port, 
                      dst_ip=dst_ip, 
                      dst_port=dst_port, 
                      msg=msg, 
                      content=content, 
                      sid=sid,
                      rev=rev,
                      nocase=nocase,
                      depth=depth,
                      offset=offset,
                      flags=flags,
                      pcre=pcre,
                      classtype=classtype,
                      priority=priority,
                      metadata=metadata,
                      reference=reference)
    
    # Inline comment
    comment = input("Optional inline comment (leave blank to skip): ").strip() or None
    if comment:
        rule += f"  # {comment}"

    # Preview and confirm
    print("\nGenerated Rule:")
    print(rule)
    confirm = input("\nSave this rule to file? [y/N]: ").strip().lower()
    if confirm != "y":
        print("Rule not saved.")
        return

    # Output to file
    if os.path.exists(out_path):
        print(f"Warning: {out_path} already exists and will be appended to.")
    try:
        dir_path = os.path.dirname(out_path) or "."
        os.makedirs(dir_path, exist_ok=True)
        with open(out_path, "a"):
            pass
    except Exception as e:
        raise IOError(f"Cannot write to output file '{out_path}': {e}")

    with open(out_path, "a") as f:
        f.write(rule + "\n")

    print(f"\nRule saved to {out_path}")


def run(args, config=None) -> None:
    """
    Handles non-interactive rule generation via CLI arguments.

    Args:
        args: Parsed argparse.Namespace containing CLI options.
        config: Optional dict of config overrides (from TOML).
    """
    try:
        config = config or {}

        # Handle offset/depth combo
        offset = _resolve(args.offset, config, "default_offset", None)
        depth = _resolve(args.depth, config, "default_depth", None)
        if offset is not None or depth is not None:
            offset, depth = _validate_offset_depth(offset, depth)

        # Determine SID
        sid = _resolve(args.sid, config, "sid", None)
        if sid is None:
            sid = _get_next_sid()

        # Output and Revision
        out_path = _resolve(args.outfile, config, "default_outfile", "rules/local.rules")
        rev = _get_latest_revision(out_path, sid)

        # Build rule from inputs
        rule = _build_rule(
            proto=_resolve(args.proto, config, "default_proto", "tcp"),
            src_ip=_resolve(args.src_ip, config, "default_src_ip", "any"),
            src_port=_resolve(args.src_port, config, "default_src_port", "any"),
            dst_ip=_resolve(args.dst_ip, config, "default_dst_ip", "$HOME_NET"),
            dst_port=_resolve(args.dst_port, config, "default_dst_port", "80"),
            msg=_resolve(args.msg, config, "default_msg", "Generated by Snortsmith"),
            content=_resolve(args.content, config, "default_content", None),
            sid=sid,
            rev=rev,
            nocase=_resolve(args.nocase, config, "default_nocase", None),
            depth=depth,
            offset=offset,
            flags=_resolve(args.flags, config, "default_flags", None),
            pcre=_resolve(args.pcre, config, "default_pcre", None),
            classtype=_resolve(args.classtype, config, "default_classtype", None),
            priority=_resolve(args.priority, config, "default_priority", None),
            metadata=_resolve(args.metadata, config, "default_metadata", None),
            reference=_resolve(args.reference, config, "default_reference", None),
        )

        if args.comment:
            rule += f"  # {args.comment.strip()}"

        # Preview and confirm if dry-run
        print("\nGenerated Rule:")
        print(rule)
        if args.dry_run:
            confirm = input("\nSave this rule to file? [y/N]: ").strip().lower()
            if confirm != "y":
                print("Rule not saved.")
                return

        if args.verbose and os.path.exists(out_path):
            print(f"Warning: {out_path} already exists and will be appended to.")
        
        try:
            dir_path = os.path.dirname(out_path) or "."
            os.makedirs(dir_path, exist_ok=True)
            with open(out_path, "a"):
                pass
        except Exception as e:
            raise IOError(f"Cannot write to output file '{out_path}': {e}")

        with open(out_path, "a") as f:
            f.write(rule + "\n")

        print(f"\nRule saved to {out_path}")
    except Exception as e:
        print(f"[ERROR] Rule generation failed: {e}")